/* * Copyright (c) 2019. * This file is part of Metronome. * *      Metronome is free software: you can redistribute it and/or modify *      it under the terms of the GNU General Public License as published by *      the Free Software Foundation, either version 3 of the License, or *      (at your option) any later version. * *      Metronome is distributed in the hope that it will be useful, *      but WITHOUT ANY WARRANTY; without even the implied warranty of *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *      GNU General Public License for more details. * *      You should have received a copy of the GNU General Public License *      along with Metronome.  If not, see <http://www.gnu.org/licenses/>. */package tk.radioactivemineral.metronome;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.Window;import android.view.WindowManager;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.io.FileOutputStream;import java.io.IOException;public class SaveDialogActivity extends Activity {	public final static String DATA_STORAGE_FILE_NAME = "presets";	public final static String EMPTY_NAME_FLAG_INTENT_NAME = "empty_flag";	private final static String LOG_TAG = "SaveDialogActivity";	EditText editText;	Button buttonOK;	Button buttonCancel;	Boolean success, emptyNameFlag;	@Override	protected void onCreate(Bundle savedInstanceState) {		super.onCreate(savedInstanceState);		// Make us non-modal, so that others can receive touch events.		getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL, WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);		// ...but notify us that it happened.		getWindow().setFlags(WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH, WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);		//remove the title bar		requestWindowFeature(Window.FEATURE_NO_TITLE);		setContentView(R.layout.activity_save_dialog);		//fill the screen on the horizontal access		//Grab the window of the dialog, and change the width		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();		Window window = getWindow();		lp.copyFrom(window.getAttributes());		//change size		//lp.width = WindowManager.LayoutParams.MATCH_PARENT;		lp.width = (int)(getResources().getDisplayMetrics().widthPixels*0.9);;		lp.height = WindowManager.LayoutParams.WRAP_CONTENT;		window.setAttributes(lp);		//init		final int beats = getIntent().getExtras().getInt(MetronomeActivity.DIALOG_SAVE_BEATS);		final int bpm = getIntent().getExtras().getInt(MetronomeActivity.DIALOG_SAVE_BPM);		final double beatSound = getIntent().getExtras().getDouble(MetronomeActivity.DIALOG_SAVE_BEAT_SOUND);		final double sound = getIntent().getExtras().getDouble(MetronomeActivity.DIALOG_SAVE_SOUND);		final String uniqueID = getIntent().getExtras().getString(MetronomeActivity.DIALOG_SAVE_ID);		final String wave = getIntent().getExtras().getString(MetronomeActivity.DIALOG_SAVE_WAVE);		editText = findViewById(R.id.editTextDialog);		buttonOK = findViewById(R.id.buttonOK);		buttonCancel = findViewById(R.id.buttonCancel);		//assume write will work		success = true;		emptyNameFlag = false;		//user clicked save, do so.		buttonOK.setOnClickListener(new View.OnClickListener() {			@Override			public void onClick(View v) {				//check for a valid name				if (!editText.getText().toString().equals("") && !editText.getText().toString().contains(MiscUtils.separator + "")) {					FileOutputStream fileOutputStream;					String data, oldData;					//check if the storage file exists, if not, create it					if (!MiscUtils.fileExists(SaveDialogActivity.this, DATA_STORAGE_FILE_NAME)) {						try {							fileOutputStream = openFileOutput(DATA_STORAGE_FILE_NAME, Context.MODE_PRIVATE);							fileOutputStream.write("".getBytes());							fileOutputStream.close();						} catch (IOException e) {							Log.w(LOG_TAG, "failed to read!\n" + e.toString());						}					}					data = MiscUtils.prepareForStorage(editText.getText().toString(), beats, bpm, MetronomeActivity.AUTO_SAVE_FLAG_FALSE, beatSound, sound, uniqueID, wave);					try {						//save the data						//read the old data						oldData = MiscUtils.readSavedData(SaveDialogActivity.this);						fileOutputStream = openFileOutput(DATA_STORAGE_FILE_NAME, Context.MODE_PRIVATE);						fileOutputStream.write((oldData + data).getBytes());						fileOutputStream.close();					} catch (IOException ex) {						Log.w(LOG_TAG, "failed to save!\n" + ex.toString());						Toast.makeText(SaveDialogActivity.this, getResources().getText(R.string.save_fail_toast), Toast.LENGTH_SHORT).show();						//failed to save!!						success = false;						emptyNameFlag = true;					}					//set the flag of the save					SharedPreferences preferences = getSharedPreferences(MetronomeActivity.PREFS_NAME, 0);					SharedPreferences.Editor editor = preferences.edit();					editor.putBoolean(MetronomeActivity.DB_SAVE_EXISTS, success);					//commit					editor.apply();					//set the result					Intent resultIntent = new Intent();					resultIntent.putExtra(EMPTY_NAME_FLAG_INTENT_NAME, emptyNameFlag);					setResult(Activity.RESULT_OK, resultIntent);					//finish the activity					finish();				} else if (editText.getText().toString().contains(MiscUtils.separator + "") || editText.getText().toString().contains(MiscUtils.newline + ""))					Toast.makeText(SaveDialogActivity.this, "Name can't have:\n'" + MiscUtils.separator + "'\n" + "Or:\n" + MiscUtils.newline, Toast.LENGTH_SHORT).show();				else					Toast.makeText(SaveDialogActivity.this, "Empty name!", Toast.LENGTH_SHORT).show();			}		});		//user clicked cancel, do so		buttonCancel.setOnClickListener(new View.OnClickListener() {			@Override			public void onClick(View view) {				//set the result				Intent resultIntent = new Intent();				resultIntent.putExtra(EMPTY_NAME_FLAG_INTENT_NAME, true);				setResult(Activity.RESULT_CANCELED, resultIntent);				//finish the activity				finish();			}		});	}	@Override	public boolean onTouchEvent(MotionEvent event) {		// If we've received a touch notification that the user has touched		// outside the app, finish the activity.		if (MotionEvent.ACTION_OUTSIDE == event.getAction()) {			//set the result			Intent resultIntent = new Intent();			resultIntent.putExtra(EMPTY_NAME_FLAG_INTENT_NAME, true);			setResult(Activity.RESULT_CANCELED, resultIntent);			//finish the activity			finish();			return true;		}		// Delegate everything else to Activity.		return super.onTouchEvent(event);	}}